/// <reference path="../typings/simd.d.ts" />
interface Math {
    sign(n: number): number;
}
declare namespace veclib {
    const EPSILON = 0.000001;
    function clamp(n: number, min: number, max: number): number;
    function clamp01(n: number): number;
    function mix(a: number, b: number, ratio: number): number;
    interface MutableArrayLike<T> {
        readonly length: number;
        [n: number]: T;
    }
    type ArrayOfConstNumber = ArrayLike<number>;
    type ArrayOfNumber = MutableArrayLike<number>;
    interface TypedArrayBase {
        subarray(start: number, end: number): this;
    }
    type Float2 = ArrayOfNumber;
    type Float3 = ArrayOfNumber;
    type Float4 = ArrayOfNumber;
    type Float2x2 = ArrayOfNumber;
    type Float3x3 = ArrayOfNumber;
    type Float4x4 = ArrayOfNumber;
    type ConstFloat2 = ArrayOfConstNumber;
    type ConstFloat3 = ArrayOfConstNumber;
    type ConstFloat4 = ArrayOfConstNumber;
    type ConstFloat2x2 = ArrayOfConstNumber;
    type ConstFloat3x3 = ArrayOfConstNumber;
    type ConstFloat4x4 = ArrayOfConstNumber;
    interface VecArrayIterationOptions {
        stride?: number;
        offset?: number;
        count?: number;
    }
    type VecArrayIterationFunction = (out: ArrayOfNumber, a: ArrayOfConstNumber, ...args: any[]) => void;
    function refIndexedVec2<T extends TypedArrayBase>(data: T, index: number): T;
    function copyIndexedVec2(data: ArrayOfConstNumber, index: number): number[];
    function setIndexedVec2(data: ArrayOfNumber, index: number, v2: ConstFloat2): void;
    function copyVec2FromOffset(data: ArrayOfConstNumber, offset: number): number[];
    function setVec2AtOffset(data: ArrayOfNumber, offset: number, v2: ConstFloat2): void;
    function offsetOfIndexedVec2(index: number): number;
    function refIndexedVec3<T extends TypedArrayBase>(data: T, index: number): T;
    function copyIndexedVec3(data: ArrayOfConstNumber, index: number): number[];
    function setIndexedVec3(data: ArrayOfNumber, index: number, v3: ConstFloat3): void;
    function copyVec3FromOffset(data: ArrayOfConstNumber, offset: number): number[];
    function setVec3AtOffset(data: ArrayOfNumber, offset: number, v3: ConstFloat3): void;
    function offsetOfIndexedVec3(index: number): number;
    function refIndexedVec4<T extends TypedArrayBase>(data: T, index: number): T;
    function copyIndexedVec4(data: ArrayOfConstNumber, index: number): number[];
    function setIndexedVec4(data: ArrayOfNumber, index: number, v4: ConstFloat4): void;
    function copyVec4FromOffset(data: ArrayOfConstNumber, offset: number): number[];
    function setVec4AtOffset(data: ArrayOfNumber, offset: number, v4: ConstFloat4): void;
    function offsetOfIndexedVec4(index: number): number;
    function refIndexedMat3<T extends TypedArrayBase>(data: T, index: number): T;
    function copyIndexedMat3(data: ArrayOfConstNumber, index: number): number[];
    function setIndexedMat3(data: ArrayOfNumber, index: number, m3: ConstFloat3x3): void;
    function offsetOfIndexedMat3(index: number): number;
    function refIndexedMat4<T extends TypedArrayBase>(data: T, index: number): T;
    function copyIndexedMat4(data: ArrayOfConstNumber, index: number): number[];
    function setIndexedMat4(data: ArrayOfNumber, index: number, m4: ConstFloat4x4): void;
    function offsetOfIndexedMat4(index: number): number;
}
declare namespace veclib.mat2 {
    import AN = veclib.ArrayOfNumber;
    import ACN = veclib.ArrayOfConstNumber;
    const ELEMENT_COUNT = 4;
    function create(): Float32Array;
    function clone(a: ACN): Float32Array;
    function copy(out: number[], a: ACN): number[];
    function copy<T extends AN>(out: T, a: ACN): T;
    function identity(out: number[]): number[];
    function identity<T extends AN>(out: T): T;
    function fromValues(m00: number, m01: number, m10: number, m11: number): Float32Array;
    function set(out: number[], m00: number, m01: number, m10: number, m11: number): number[];
    function set<T extends AN>(out: T, m00: number, m01: number, m10: number, m11: number): T;
    function transpose(out: number[], a: ACN): number[];
    function transpose<T extends AN>(out: T, a: ACN): T;
    function invert(out: number[], a: ACN): number[];
    function invert<T extends AN>(out: T, a: ACN): T;
    function adjoint(out: number[], a: ACN): number[];
    function adjoint<T extends AN>(out: T, a: ACN): T;
    function determinant(a: ACN): number;
    function multiply(out: number[], a: ACN, b: ACN): number[];
    function multiply<T extends AN>(out: T, a: ACN, b: ACN): T;
    const mul: typeof multiply;
    function rotate(out: number[], a: ACN, rad: number): number[];
    function rotate<T extends AN>(out: T, a: ACN, rad: number): T;
    function scale(out: number[], a: ACN, v2: ACN): number[];
    function scale<T extends AN>(out: T, a: ACN, v2: ACN): T;
    function fromRotation(out: number[], rad: number): number[];
    function fromRotation<T extends AN>(out: T, rad: number): T;
    function fromScaling(out: number[], v2: ACN): number[];
    function fromScaling<T extends AN>(out: T, v2: ACN): T;
    function str(a: ACN): string;
    function frob(a: ACN): number;
    function LDU(L: AN, D: ACN, U: AN, a: ACN): ArrayLike<number>[];
    function add(out: number[], a: ACN, b: ACN): number[];
    function add<T extends AN>(out: T, a: ACN, b: ACN): T;
    function subtract(out: number[], a: ACN, b: ACN): number[];
    function subtract<T extends AN>(out: T, a: ACN, b: ACN): T;
    const sub: typeof subtract;
    function multiplyScalar(out: number[], a: ACN, scale: number): number[];
    function multiplyScalar<T extends AN>(out: T, a: ACN, scale: number): T;
    function multiplyScalarAndAdd(out: number[], a: ACN, b: ACN, scale: number): number[];
    function multiplyScalarAndAdd<T extends AN>(out: T, a: ACN, b: ACN, scale: number): T;
    function exactEquals(a: ACN, b: ACN): boolean;
    function equals(a: ACN, b: ACN): boolean;
}
declare namespace veclib.mat2d {
    import AN = veclib.ArrayOfNumber;
    import ACN = veclib.ArrayOfConstNumber;
    const ELEMENT_COUNT = 6;
    function create(): Float32Array;
    function clone(a: ACN): Float32Array;
    function copy(out: number[], a: ACN): number[];
    function copy<T extends AN>(out: T, a: ACN): T;
    function identity(out: number[]): number[];
    function identity<T extends AN>(out: T): T;
    function fromValues(a: number, b: number, c: number, d: number, tx: number, ty: number): Float32Array;
    function set(out: number[], a: number, b: number, c: number, d: number, tx: number, ty: number): number[];
    function set<T extends AN>(out: T, a: number, b: number, c: number, d: number, tx: number, ty: number): T;
    function invert(out: number[], a: ACN): number[];
    function invert<T extends AN>(out: T, a: ACN): T;
    function determinant(a: ACN): number;
    function multiply(out: number[], a: ACN, b: ACN): number[];
    function multiply<T extends AN>(out: T, a: ACN, b: ACN): T;
    const mul: typeof multiply;
    function rotate(out: number[], a: ACN, rad: number): number[];
    function rotate<T extends AN>(out: T, a: ACN, rad: number): T;
    function scale(out: number[], a: ACN, v2: ACN): number[];
    function scale<T extends AN>(out: T, a: ACN, v2: ACN): T;
    function translate(out: number[], a: ACN, v2: ACN): number[];
    function translate<T extends AN>(out: T, a: ACN, v2: ACN): T;
    function fromRotation(out: number[], rad: number): number[];
    function fromRotation<T extends AN>(out: T, rad: number): T;
    function fromScaling(out: number[], v2: ACN): number[];
    function fromScaling<T extends AN>(out: T, v2: ACN): T;
    function fromTranslation(out: number[], v2: ACN): number[];
    function fromTranslation<T extends AN>(out: T, v2: ACN): T;
    function str(a: ACN): string;
    function frob(a: ACN): number;
    function add(out: number[], a: ACN, b: ACN): number[];
    function add<T extends AN>(out: T, a: ACN, b: ACN): T;
    function subtract(out: number[], a: ACN, b: ACN): number[];
    function subtract<T extends AN>(out: T, a: ACN, b: ACN): T;
    const sub: typeof subtract;
    function multiplyScalar(out: number[], a: ACN, scale: number): number[];
    function multiplyScalar<T extends AN>(out: T, a: ACN, scale: number): T;
    function multiplyScalarAndAdd(out: number[], a: ACN, b: ACN, scale: number): number[];
    function multiplyScalarAndAdd<T extends AN>(out: T, a: ACN, b: ACN, scale: number): T;
    function exactEquals(a: ACN, b: ACN): boolean;
    function equals(a: ACN, b: ACN): boolean;
}
declare namespace veclib.mat3 {
    import AN = veclib.ArrayOfNumber;
    import ACN = veclib.ArrayOfConstNumber;
    const ELEMENT_COUNT = 9;
    function create(): Float32Array;
    function clone(a: ACN): Float32Array;
    function copy(out: number[], a: ACN): number[];
    function copy<T extends AN>(out: T, a: ACN): T;
    function identity(out: number[]): number[];
    function identity<T extends AN>(out: T): T;
    function fromValues(m00: number, m01: number, m02: number, m10: number, m11: number, m12: number, m20: number, m21: number, m22: number): Float32Array;
    function set(out: number[], m00: number, m01: number, m02: number, m10: number, m11: number, m12: number, m20: number, m21: number, m22: number): number[];
    function set<T extends AN>(out: T, m00: number, m01: number, m02: number, m10: number, m11: number, m12: number, m20: number, m21: number, m22: number): T;
    function transpose(out: number[], a: ACN): number[];
    function transpose<T extends AN>(out: T, a: ACN): T;
    function invert(out: number[], a: ACN): number[];
    function invert<T extends AN>(out: T, a: ACN): T;
    function adjoint(out: number[], a: ACN): number[];
    function adjoint<T extends AN>(out: T, a: ACN): T;
    function determinant(a: ACN): number;
    function multiply(out: number[], a: ACN, b: ACN): number[];
    function multiply<T extends AN>(out: T, a: ACN, b: ACN): T;
    const mul: typeof multiply;
    function rotate(out: number[], a: ACN, rad: number): number[];
    function rotate<T extends AN>(out: T, a: ACN, rad: number): T;
    function scale(out: number[], a: ACN, v2: ACN): number[];
    function scale<T extends AN>(out: T, a: ACN, v2: ACN): T;
    function translate(out: number[], a: ACN, v2: ACN): number[];
    function translate<T extends AN>(out: T, a: ACN, v2: ACN): T;
    function fromRotation(out: number[], rad: number): number[];
    function fromRotation<T extends AN>(out: T, rad: number): T;
    function fromScaling(out: number[], v2: ACN): number[];
    function fromScaling<T extends AN>(out: T, v2: ACN): T;
    function fromTranslation(out: number[], v2: ACN): number[];
    function fromTranslation<T extends AN>(out: T, v2: ACN): T;
    function fromMat2d(out: number[], m2d: ACN): number[];
    function fromMat2d<T extends AN>(out: T, m2d: ACN): T;
    function fromMat4(out: number[], m4: ACN): number[];
    function fromMat4<T extends AN>(out: T, m4: ACN): T;
    function fromQuat(out: number[], q: ACN): number[];
    function fromQuat<T extends AN>(out: T, q: ACN): T;
    function normalFromMat4(out: number[], m4: ACN): number[];
    function normalFromMat4<T extends AN>(out: T, m4: ACN): T;
    function str(a: ACN): string;
    function frob(a: ACN): number;
    function add(out: number[], a: ACN, b: ACN): number[];
    function add<T extends AN>(out: T, a: ACN, b: ACN): T;
    function subtract(out: number[], a: ACN, b: ACN): number[];
    function subtract<T extends AN>(out: T, a: ACN, b: ACN): T;
    const sub: typeof subtract;
    function multiplyScalar(out: number[], a: ACN, scale: number): number[];
    function multiplyScalar<T extends AN>(out: T, a: ACN, scale: number): T;
    function multiplyScalarAndAdd(out: number[], a: ACN, b: ACN, scale: number): number[];
    function multiplyScalarAndAdd<T extends AN>(out: T, a: ACN, b: ACN, scale: number): T;
    function exactEquals(a: ACN, b: ACN): boolean;
    function equals(a: ACN, b: ACN): boolean;
}
declare namespace veclib.mat4simd {
    function transpose(out: Float32Array, a: Float32Array): Float32Array;
    function invert(out: Float32Array, a: Float32Array): Float32Array | null;
    function adjoint(out: Float32Array, a: Float32Array): Float32Array;
    function multiply(out: Float32Array, a: Float32Array, b: Float32Array): Float32Array;
    function rotateX(out: Float32Array, a: Float32Array, rad: number): Float32Array;
    function rotateY(out: Float32Array, a: Float32Array, rad: number): Float32Array;
    function rotateZ(out: Float32Array, a: Float32Array, rad: number): Float32Array;
    function scale(out: Float32Array, a: Float32Array, v3: Float32Array): Float32Array;
    function translate(out: Float32Array, a: Float32Array, v3: Float32Array): Float32Array;
}
declare namespace veclib.mat4 {
    import AN = veclib.ArrayOfNumber;
    import ACN = veclib.ArrayOfConstNumber;
    const ELEMENT_COUNT = 16;
    function create(): Float32Array;
    function clone(a: ACN): Float32Array;
    function copy(out: number[], a: ACN): number[];
    function copy<T extends AN>(out: T, a: ACN): T;
    function identity(out: number[]): number[];
    function identity<T extends AN>(out: T): T;
    function fromValues(m00: number, m01: number, m02: number, m03: number, m10: number, m11: number, m12: number, m13: number, m20: number, m21: number, m22: number, m23: number, m30: number, m31: number, m32: number, m33: number): Float32Array;
    function set(out: number[], m00: number, m01: number, m02: number, m03: number, m10: number, m11: number, m12: number, m13: number, m20: number, m21: number, m22: number, m23: number, m30: number, m31: number, m32: number, m33: number): number[];
    function set<T extends AN>(out: T, m00: number, m01: number, m02: number, m03: number, m10: number, m11: number, m12: number, m13: number, m20: number, m21: number, m22: number, m23: number, m30: number, m31: number, m32: number, m33: number): T;
    function transpose(out: number[], a: ACN): number[];
    function transpose<T extends AN>(out: T, a: ACN): T;
    function invert(out: number[], a: ACN): number[];
    function invert<T extends AN>(out: T, a: ACN): T;
    function adjoint(out: number[], a: ACN): number[];
    function adjoint<T extends AN>(out: T, a: ACN): T;
    function determinant(a: ACN): number;
    function multiply(out: number[], a: ACN, b: ACN): number[];
    function multiply<T extends AN>(out: T, a: ACN, b: ACN): T;
    const mul: typeof multiply;
    function rotate(out: number[], a: ACN, rad: number, axis: ACN): number[];
    function rotate<T extends AN>(out: T, a: ACN, rad: number, axis: ACN): T;
    function rotateX(out: number[], a: ACN, rad: number): number[];
    function rotateX<T extends AN>(out: T, a: ACN, rad: number): T;
    function rotateY(out: number[], a: ACN, rad: number): number[];
    function rotateY<T extends AN>(out: T, a: ACN, rad: number): T;
    function rotateZ(out: number[], a: ACN, rad: number): number[];
    function rotateZ<T extends AN>(out: T, a: ACN, rad: number): T;
    function scale(out: number[], a: ACN, v3: ACN): number[];
    function scale<T extends AN>(out: T, a: ACN, v3: ACN): T;
    function translate(out: number[], a: ACN, v3: ACN): number[];
    function translate<T extends AN>(out: T, a: ACN, v3: ACN): T;
    function fromRotation(out: number[], rad: number, axis: ACN): number[];
    function fromRotation<T extends AN>(out: T, rad: number, axis: ACN): T;
    function fromScaling(out: number[], v3: ACN): number[];
    function fromScaling<T extends AN>(out: T, v3: ACN): T;
    function fromTranslation(out: number[], v3: ACN): number[];
    function fromTranslation<T extends AN>(out: T, v3: ACN): T;
    function fromXRotation(out: number[], rad: number): number[];
    function fromXRotation<T extends AN>(out: T, rad: number): T;
    function fromYRotation(out: number[], rad: number): number[];
    function fromYRotation<T extends AN>(out: T, rad: number): T;
    function fromZRotation(out: number[], rad: number): number[];
    function fromZRotation<T extends AN>(out: T, rad: number): T;
    function fromRotationTranslation(out: number[], q: ACN, v3: ACN): number[];
    function fromRotationTranslation<T extends AN>(out: T, q: ACN, v3: ACN): T;
    function fromRotationTranslationScale(out: number[], q: ACN, v: ACN, s: ACN): number[];
    function fromRotationTranslationScale<T extends AN>(out: T, q: ACN, v: ACN, s: ACN): T;
    function fromRotationTranslationScaleOrigin(out: number[], q: ACN, v: ACN, s: ACN, o: ACN): number[];
    function fromRotationTranslationScaleOrigin<T extends AN>(out: T, q: ACN, v: ACN, s: ACN, o: ACN): T;
    function fromQuat(out: number[], q: ACN): number[];
    function fromQuat<T extends AN>(out: T, q: ACN): T;
    function getTranslation(out: number[], a: ACN): number[];
    function getTranslation<T extends AN>(out: T, a: ACN): T;
    function getScaling(out: number[], a: ACN): number[];
    function getScaling<T extends AN>(out: T, a: ACN): T;
    function getRotation(out: number[], a: ACN): number[];
    function getRotation<T extends AN>(out: T, a: ACN): T;
    function frustum(out: number[], left: number, right: number, bottom: number, top: number, near: number, far: number): number[];
    function frustum<T extends AN>(out: T, left: number, right: number, bottom: number, top: number, near: number, far: number): T;
    function perspective(out: number[], fovy: number, aspect: number, near: number, far: number): number[];
    function perspective<T extends AN>(out: T, fovy: number, aspect: number, near: number, far: number): T;
    interface FieldOfViewDegrees {
        upDegrees: number;
        downDegrees: number;
        leftDegrees: number;
        rightDegrees: number;
    }
    function perspectiveFromFieldOfView(out: number[], fov: FieldOfViewDegrees, near: number, far: number): number[];
    function perspectiveFromFieldOfView<T extends AN>(out: T, fov: FieldOfViewDegrees, near: number, far: number): T;
    function ortho(out: number[], left: number, right: number, bottom: number, top: number, near: number, far: number): number[];
    function ortho<T extends AN>(out: T, left: number, right: number, bottom: number, top: number, near: number, far: number): T;
    function lookAt(out: number[], eye: ACN, center: ACN, up: ACN): number[];
    function lookAt<T extends AN>(out: T, eye: ACN, center: ACN, up: ACN): T;
    function str(a: ACN): string;
    function frob(a: ACN): number;
    function add(out: number[], a: ACN, b: ACN): number[];
    function add<T extends AN>(out: T, a: ACN, b: ACN): T;
    function subtract(out: number[], a: ACN, b: ACN): number[];
    function subtract<T extends AN>(out: T, a: ACN, b: ACN): T;
    const sub: typeof subtract;
    function multiplyScalar(out: number[], a: ACN, scale: number): number[];
    function multiplyScalar<T extends AN>(out: T, a: ACN, scale: number): T;
    function multiplyScalarAndAdd(out: number[], a: ACN, b: ACN, scale: number): number[];
    function multiplyScalarAndAdd<T extends AN>(out: T, a: ACN, b: ACN, scale: number): T;
    function exactEquals(a: ACN, b: ACN): boolean;
    function equals(a: ACN, b: ACN): boolean;
}
declare namespace veclib.quat {
    import AN = veclib.ArrayOfNumber;
    import ACN = veclib.ArrayOfConstNumber;
    const ELEMENT_COUNT = 4;
    function create(): Float32Array;
    function rotationTo(out: number[], a: ACN, b: ACN): number[];
    function rotationTo<T extends AN>(out: T, a: ACN, b: ACN): T;
    function setAxes(out: number[], view: ACN, right: ACN, up: ACN): number[];
    function setAxes<T extends AN>(out: T, view: ACN, right: ACN, up: ACN): T;
    const clone: typeof vec4.clone;
    const fromValues: typeof vec4.fromValues;
    const copy: typeof vec4.copy;
    const set: typeof vec4.set;
    function identity(out: number[]): number[];
    function identity<T extends AN>(out: T): T;
    function setAxisAngle(out: number[], axis: ACN, rad: number): number[];
    function setAxisAngle<T extends AN>(out: T, axis: ACN, rad: number): T;
    function getAxisAngle(outAxis: AN, q: ACN): number;
    const add: typeof vec4.add;
    function multiply(out: number[], a: ACN, b: ACN): number[];
    function multiply<T extends AN>(out: T, a: ACN, b: ACN): T;
    const mul: typeof multiply;
    const scale: typeof vec4.scale;
    function rotateX(out: number[], a: ACN, rad: number): number[];
    function rotateX<T extends AN>(out: T, a: ACN, rad: number): T;
    function rotateY(out: number[], a: ACN, rad: number): number[];
    function rotateY<T extends AN>(out: T, a: ACN, rad: number): T;
    function rotateZ(out: number[], a: ACN, rad: number): number[];
    function rotateZ<T extends AN>(out: T, a: ACN, rad: number): T;
    function calculateW(out: number[], a: ACN): number[];
    function calculateW<T extends AN>(out: T, a: ACN): T;
    const dot: typeof vec4.dot;
    const lerp: typeof vec4.lerp;
    function slerp(out: number[], a: ACN, b: ACN, t: number): number[];
    function slerp<T extends AN>(out: T, a: ACN, b: ACN, t: number): T;
    function sqlerp(out: number[], a: ACN, b: ACN, c: ACN, d: ACN, t: number): number[];
    function sqlerp<T extends AN>(out: AN, a: ACN, b: ACN, c: ACN, d: ACN, t: number): T;
    function invert(out: number[], a: ACN): number[];
    function invert<T extends AN>(out: T, a: ACN): T;
    function conjugate(out: number[], a: ACN): number[];
    function conjugate<T extends AN>(out: T, a: ACN): T;
    const length: typeof vec4.length;
    const len: typeof vec4.length;
    const squaredLength: typeof vec4.squaredLength;
    const sqrLen: typeof vec4.squaredLength;
    const normalize: typeof vec4.normalize;
    function fromMat3(out: number[], m: ACN): number[];
    function fromMat3<T extends AN>(out: T, m: ACN): T;
    function fromEuler(yaw: number, pitch: number, roll: number): Float32Array;
    function str(a: ACN): string;
    const exactEquals: typeof vec4.exactEquals;
    const equals: typeof vec4.equals;
}
declare namespace veclib.vec2 {
    import AN = veclib.ArrayOfNumber;
    import ACN = veclib.ArrayOfConstNumber;
    const ELEMENT_COUNT = 2;
    function create(): Float32Array;
    const zero: typeof create;
    function one(): Float32Array;
    function clone(a: ACN): Float32Array;
    function fromValues(x: number, y: number): Float32Array;
    function copy(out: number[], a: ACN): number[];
    function copy<T extends AN>(out: T, a: ACN): T;
    function set(out: number[], x: number, y: number): number[];
    function set<T extends AN>(out: T, x: number, y: number): T;
    function add(out: number[], a: ACN, b: ACN): number[];
    function add<T extends AN>(out: T, a: ACN, b: ACN): T;
    function subtract(out: number[], a: ACN, b: ACN): number[];
    function subtract<T extends AN>(out: T, a: ACN, b: ACN): T;
    const sub: typeof subtract;
    function multiply(out: number[], a: ACN, b: ACN): number[];
    function multiply<T extends AN>(out: T, a: ACN, b: ACN): T;
    const mul: typeof multiply;
    function divide(out: number[], a: ACN, b: ACN): number[];
    function divide<T extends AN>(out: T, a: ACN, b: ACN): T;
    const div: typeof divide;
    function ceil(out: number[], a: ACN): number[];
    function ceil<T extends AN>(out: T, a: ACN): T;
    function floor(out: number[], a: ACN): number[];
    function floor<T extends AN>(out: T, a: ACN): T;
    function min(out: number[], a: ACN, b: ACN): number[];
    function min<T extends AN>(out: T, a: ACN, b: ACN): T;
    function max(out: number[], a: ACN, b: ACN): number[];
    function max<T extends AN>(out: T, a: ACN, b: ACN): T;
    function round(out: number[], a: ACN): number[];
    function round<T extends AN>(out: T, a: ACN): T;
    function scale(out: number[], a: ACN, s: number): number[];
    function scale<T extends AN>(out: T, a: ACN, s: number): T;
    function scaleAndAdd(out: number[], a: ACN, b: ACN, scale: number): number[];
    function scaleAndAdd<T extends AN>(out: T, a: ACN, b: ACN, scale: number): T;
    function distance(a: ACN, b: ACN): number;
    const dist: typeof distance;
    function squaredDistance(a: ACN, b: ACN): number;
    const sqrDist: typeof squaredDistance;
    function length(a: ACN): number;
    const len: typeof length;
    function squaredLength(a: ACN): number;
    const sqrLen: typeof squaredLength;
    function negate(out: number[], a: ACN): number[];
    function negate<T extends AN>(out: T, a: ACN): T;
    function inverse(out: number[], a: ACN): number[];
    function inverse<T extends AN>(out: T, a: ACN): T;
    function normalize(out: number[], a: ACN): number[];
    function normalize<T extends AN>(out: T, a: ACN): T;
    function dot(a: ACN, b: ACN): number;
    function cross(out: number[], a: ACN, b: ACN): number[];
    function cross<T extends AN>(out: T, a: ACN, b: ACN): T;
    function lerp(out: number[], a: ACN, b: ACN, t: number): number[];
    function lerp<T extends AN>(out: T, a: ACN, b: ACN, t: number): T;
    function random(out: number[], scale: number): number[];
    function random<T extends AN>(out: T, scale: number): T;
    function clamp(out: number[], a: ACN, min: number, max: number): number[];
    function clamp<T extends AN>(out: AN, a: ACN, min: number, max: number): T;
    function clamp(out: number[], a: ACN, min: ACN, max: ACN): number[];
    function clamp<T extends AN>(out: AN, a: ACN, min: ACN, max: ACN): T;
    function clamp01(out: number[], a: ACN): number[];
    function clamp01<T extends AN>(out: T, a: ACN): T;
    function mix(out: number[], a: ACN, b: ACN, ratio: number): number[];
    function mix<T extends AN>(out: T, a: ACN, b: ACN, ratio: number): T;
    function mix(out: number[], a: ACN, b: ACN, ratios: ACN): number[];
    function mix<T extends AN>(out: T, a: ACN, b: ACN, ratios: ACN): T;
    function sign(out: number[], a: ACN): number[];
    function sign<T extends AN>(out: T, a: ACN): T;
    function transformMat2(out: number[], a: ACN, m: ACN): number[];
    function transformMat2<T extends AN>(out: T, a: ACN, m: ACN): T;
    function transformMat2d(out: number[], a: ACN, m: ACN): number[];
    function transformMat2d<T extends AN>(out: T, a: ACN, m: ACN): T;
    function transformMat3(out: number[], a: ACN, m: ACN): number[];
    function transformMat3<T extends AN>(out: T, a: ACN, m: ACN): T;
    function transformMat4(out: number[], a: ACN, m: ACN): number[];
    function transformMat4<T extends AN>(out: T, a: ACN, m: ACN): T;
    function forEach(a: number[], opt: VecArrayIterationOptions, fn: VecArrayIterationFunction, ...args: any[]): number[];
    function forEach<T extends AN>(a: T, opt: VecArrayIterationOptions, fn: VecArrayIterationFunction, ...args: any[]): T;
    function str(a: ACN): string;
    function exactEquals(a: ACN, b: ACN): boolean;
    function equals(a: ACN, b: ACN): boolean;
}
declare namespace veclib.vec3 {
    import AN = veclib.ArrayOfNumber;
    import ACN = veclib.ArrayOfConstNumber;
    const ELEMENT_COUNT = 3;
    function create(): Float32Array;
    const zero: typeof create;
    function one(): Float32Array;
    function clone(a: ACN): Float32Array;
    function fromValues(x: number, y: number, z: number): Float32Array;
    function copy(out: number[], a: ACN): number[];
    function copy<T extends AN>(out: T, a: ACN): T;
    function set(out: number[], x: number, y: number, z: number): number[];
    function set<T extends AN>(out: T, x: number, y: number, z: number): T;
    function add(out: number[], a: ACN, b: ACN): number[];
    function add<T extends AN>(out: T, a: ACN, b: ACN): T;
    function subtract(out: number[], a: ACN, b: ACN): number[];
    function subtract<T extends AN>(out: T, a: ACN, b: ACN): T;
    const sub: typeof subtract;
    function multiply(out: number[], a: ACN, b: ACN): number[];
    function multiply<T extends AN>(out: T, a: ACN, b: ACN): T;
    const mul: typeof multiply;
    function divide(out: number[], a: ACN, b: ACN): number[];
    function divide<T extends AN>(out: T, a: ACN, b: ACN): T;
    const div: typeof divide;
    function ceil(out: number[], a: ACN): number[];
    function ceil<T extends AN>(out: T, a: ACN): T;
    function floor(out: number[], a: ACN): number[];
    function floor<T extends AN>(out: T, a: ACN): T;
    function min(out: number[], a: ACN, b: ACN): number[];
    function min<T extends AN>(out: T, a: ACN, b: ACN): T;
    function max(out: number[], a: ACN, b: ACN): number[];
    function max<T extends AN>(out: T, a: ACN, b: ACN): T;
    function round(out: number[], a: ACN): number[];
    function round<T extends AN>(out: T, a: ACN): T;
    function scale(out: number[], a: ACN, s: number): number[];
    function scale<T extends AN>(out: T, a: ACN, s: number): T;
    function scaleAndAdd(out: number[], a: ACN, b: ACN, scale: number): number[];
    function scaleAndAdd<T extends AN>(out: T, a: ACN, b: ACN, scale: number): T;
    function distance(a: ACN, b: ACN): number;
    const dist: typeof distance;
    function squaredDistance(a: ACN, b: ACN): number;
    const sqrDist: typeof squaredDistance;
    function length(a: ACN): number;
    const len: typeof length;
    function squaredLength(a: ACN): number;
    const sqrLen: typeof squaredLength;
    function negate(out: number[], a: ACN): number[];
    function negate<T extends AN>(out: T, a: ACN): T;
    function inverse(out: number[], a: ACN): number[];
    function inverse<T extends AN>(out: T, a: ACN): T;
    function normalize(out: number[], a: ACN): number[];
    function normalize<T extends AN>(out: T, a: ACN): T;
    function dot(a: ACN, b: ACN): number;
    function cross(out: number[], a: ACN, b: ACN): number[];
    function cross<T extends AN>(out: T, a: ACN, b: ACN): T;
    function lerp(out: number[], a: ACN, b: ACN, t: number): number[];
    function lerp<T extends AN>(out: T, a: ACN, b: ACN, t: number): T;
    function hermite(out: AN, a: ACN, b: ACN, c: ACN, d: ACN, t: number): AN;
    function bezier(out: AN, a: ACN, b: ACN, c: ACN, d: ACN, t: number): AN;
    function random(out: number[], scale: number): number[];
    function random<T extends AN>(out: T, scale: number): T;
    function clamp(out: number[], a: ACN, min: number, max: number): number[];
    function clamp<T extends AN>(out: AN, a: ACN, min: number, max: number): T;
    function clamp(out: number[], a: ACN, min: ACN, max: ACN): number[];
    function clamp<T extends AN>(out: AN, a: ACN, min: ACN, max: ACN): T;
    function clamp01(out: number[], a: ACN): number[];
    function clamp01<T extends AN>(out: T, a: ACN): T;
    function mix(out: number[], a: ACN, b: ACN, ratio: number): number[];
    function mix<T extends AN>(out: T, a: ACN, b: ACN, ratio: number): T;
    function mix(out: number[], a: ACN, b: ACN, ratios: ACN): number[];
    function mix<T extends AN>(out: T, a: ACN, b: ACN, ratios: ACN): T;
    function sign(out: number[], a: ACN): number[];
    function sign<T extends AN>(out: T, a: ACN): T;
    function transformMat3(out: number[], a: ACN, m: ACN): number[];
    function transformMat3<T extends AN>(out: T, a: ACN, m: ACN): T;
    function transformMat4(out: number[], a: ACN, m: ACN): number[];
    function transformMat4<T extends AN>(out: T, a: ACN, m: ACN): T;
    function transformQuat(out: number[], a: ACN, m: ACN): number[];
    function transformQuat<T extends AN>(out: T, a: ACN, m: ACN): T;
    function rotateX(out: number[], a: ACN, b: ACN, c: number): number[];
    function rotateX<T extends AN>(out: T, a: ACN, b: ACN, c: number): T;
    function rotateY(out: number[], a: ACN, b: ACN, c: number): number[];
    function rotateY<T extends AN>(out: T, a: ACN, b: ACN, c: number): T;
    function rotateZ(out: number[], a: ACN, b: ACN, c: number): number[];
    function rotateZ<T extends AN>(out: T, a: ACN, b: ACN, c: number): T;
    function reflect(out: number[], a: ACN, normal: ACN): number[];
    function reflect<T extends AN>(out: T, a: ACN, normal: ACN): T;
    function arbitraryOrthogonalVec(a: ACN): Float32Array;
    function forEach(a: number[], opt: VecArrayIterationOptions, fn: VecArrayIterationFunction, ...args: any[]): number[];
    function forEach<T extends AN>(a: T, opt: VecArrayIterationOptions, fn: VecArrayIterationFunction, ...args: any[]): T;
    function angle(a: ACN, b: ACN): number;
    function str(a: ACN): string;
    function exactEquals(a: ACN, b: ACN): boolean;
    function equals(a: ACN, b: ACN): boolean;
}
declare namespace veclib.vec4 {
    import AN = veclib.ArrayOfNumber;
    import ACN = veclib.ArrayOfConstNumber;
    const ELEMENT_COUNT = 4;
    function create(): Float32Array;
    const zero: typeof create;
    function one(): Float32Array;
    function clone(a: ACN): Float32Array;
    function fromValues(x: number, y: number, z: number, w: number): Float32Array;
    function copy(out: number[], a: ACN): number[];
    function copy<T extends AN>(out: T, a: ACN): T;
    function set(out: number[], x: number, y: number, z: number, w: number): number[];
    function set<T extends AN>(out: T, x: number, y: number, z: number, w: number): T;
    function add(out: number[], a: ACN, b: ACN): number[];
    function add<T extends AN>(out: T, a: ACN, b: ACN): T;
    function subtract(out: number[], a: ACN, b: ACN): number[];
    function subtract<T extends AN>(out: T, a: ACN, b: ACN): T;
    const sub: typeof subtract;
    function multiply(out: number[], a: ACN, b: ACN): number[];
    function multiply<T extends AN>(out: T, a: ACN, b: ACN): T;
    const mul: typeof multiply;
    function divide(out: number[], a: ACN, b: ACN): number[];
    function divide<T extends AN>(out: T, a: ACN, b: ACN): T;
    const div: typeof divide;
    function ceil(out: number[], a: ACN): number[];
    function ceil<T extends AN>(out: T, a: ACN): T;
    function floor(out: number[], a: ACN): number[];
    function floor<T extends AN>(out: T, a: ACN): T;
    function min(out: number[], a: ACN, b: ACN): number[];
    function min<T extends AN>(out: T, a: ACN, b: ACN): T;
    function max(out: number[], a: ACN, b: ACN): number[];
    function max<T extends AN>(out: T, a: ACN, b: ACN): T;
    function round(out: number[], a: ACN): number[];
    function round<T extends AN>(out: T, a: ACN): T;
    function scale(out: number[], a: ACN, s: number): number[];
    function scale<T extends AN>(out: T, a: ACN, s: number): T;
    function scaleAndAdd(out: number[], a: ACN, b: ACN, scale: number): number[];
    function scaleAndAdd<T extends AN>(out: T, a: ACN, b: ACN, scale: number): T;
    function distance(a: ACN, b: ACN): number;
    const dist: typeof distance;
    function squaredDistance(a: ACN, b: ACN): number;
    const sqrDist: typeof squaredDistance;
    function length(a: ACN): number;
    const len: typeof length;
    function squaredLength(a: ACN): number;
    const sqrLen: typeof squaredLength;
    function negate(out: number[], a: ACN): number[];
    function negate<T extends AN>(out: T, a: ACN): T;
    function inverse(out: number[], a: ACN): number[];
    function inverse<T extends AN>(out: T, a: ACN): T;
    function normalize(out: number[], a: ACN): number[];
    function normalize<T extends AN>(out: T, a: ACN): T;
    function dot(a: ACN, b: ACN): number;
    function lerp(out: number[], a: ACN, b: ACN, t: number): number[];
    function lerp<T extends AN>(out: T, a: ACN, b: ACN, t: number): T;
    function random(out: number[], scale: number): number[];
    function random<T extends AN>(out: T, scale: number): T;
    function clamp(out: number[], a: ACN, min: number, max: number): number[];
    function clamp<T extends AN>(out: AN, a: ACN, min: number, max: number): T;
    function clamp(out: number[], a: ACN, min: ACN, max: ACN): number[];
    function clamp<T extends AN>(out: AN, a: ACN, min: ACN, max: ACN): T;
    function clamp01(out: number[], a: ACN): number[];
    function clamp01<T extends AN>(out: T, a: ACN): T;
    function mix(out: number[], a: ACN, b: ACN, ratio: number): number[];
    function mix<T extends AN>(out: T, a: ACN, b: ACN, ratio: number): T;
    function mix(out: number[], a: ACN, b: ACN, ratios: ACN): number[];
    function mix<T extends AN>(out: T, a: ACN, b: ACN, ratios: ACN): T;
    function sign(out: number[], a: ACN): number[];
    function sign<T extends AN>(out: T, a: ACN): T;
    function transformMat4(out: number[], a: ACN, m: ACN): number[];
    function transformMat4<T extends AN>(out: T, a: ACN, m: ACN): T;
    function transformQuat(out: number[], a: ACN, m: ACN): number[];
    function transformQuat<T extends AN>(out: T, a: ACN, m: ACN): T;
    function forEach(a: number[], opt: VecArrayIterationOptions, fn: VecArrayIterationFunction, ...args: any[]): number[];
    function forEach<T extends AN>(a: T, opt: VecArrayIterationOptions, fn: VecArrayIterationFunction, ...args: any[]): T;
    function str(a: ACN): string;
    function exactEquals(a: ACN, b: ACN): boolean;
    function equals(a: ACN, b: ACN): boolean;
}
